name: Docs

# Generate the documentation on all merges to main, all pull requests, or by
# manual workflow dispatch. The build job can be used as a CI check that the
# docs still build successfully. The deploy job which moves the generated
# html to the gh-pages branch and triggers a GitHub pages deployment
# only runs when a tag is pushed or when the workflow is manually dispatched
# from the main branch.
on:
  push:
    branches:
      - main
    tags:
      - '*'
  pull_request:
  merge_group:
  workflow_dispatch:

jobs:
  build_sphinx_docs:
    name: Build Sphinx Docs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/cache@v4
        with:
          path: |
            ~/.movement/*
          key: cached-test-data-${{ runner.os }}
          restore-keys: cached-test-data
      - uses: neuroinformatics-unit/actions/build_sphinx_docs@main
        with:
          python-version: 3.12
          fetch-tags: true
          use-make: true

  deploy_sphinx_docs:
    name: Deploy Sphinx Docs
    needs: build_sphinx_docs
    permissions:
      contents: write
    if: |
      (github.event_name == 'push' && github.ref_type == 'tag') ||
      (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Clear previous build if present
      shell: bash
      run: rm -rf ./docs/build

    - name: Download the content for deployment
      uses: actions/download-artifact@v4
      with:
        name: docs-build
        path: ./docs/build

    - name: Push the built HTML to gh-pages
      run: |
        # Detect if this is a release or from the main branch
        echo "Event name: ${{ github.event_name }}"
        echo "Ref type: ${{ github.ref_type }}"
        if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
            # Get the tag name without the "refs/tags/" part
            version="${GITHUB_REF#refs/*/}"
        else
            version=dev
        fi
        echo "Deploying version: $version"
        # Make the new commit message. Needs to happen before cd into deploy
        # to get the right commit hash.
        message="Deploy $version from $(git rev-parse --short HEAD)"
        cd deploy
        # Need to have this file so that Github doesn't try to run Jekyll
        touch .nojekyll
        # Delete all the files and replace with our new  set
        echo -e "\nRemoving old files from previous builds of ${version}:"
        rm -rvf ${version}
        echo -e "\nCopying HTML files to ${version}:"
        BUILD_DIR="../docs/build/html"
        cp -Rvf $BUILD_DIR ${version}/

        if [[ "${version}" != "dev" ]]; then
          SWITCHER_URL="https://animeshsasan.github.io/sphinx-deployment-test/latest/_static/switcher.json"
          echo -e "\nUpdating switcher.json at ${SWITCHER_URL} for version ${version}."
          if curl --output /dev/null --silent --head --fail "$SWITCHER_URL"; then
            # File exists, fetch and update
            SWITCHER_CONTENT=$(curl "$SWITCHER_URL")
            BASE_URL="$(jq -r '.[0].url|split("/")[0:-1]|join("/")' <<< $SWITCHER_CONTENT)"
            NEW_URL="${BASE_URL}/latest/"
            CURRENT_LATEST_VERSION=$(echo $(jq '.[0].version' <<< "${SWITCHER_CONTENT}") | tr -d '"')
            UPDATED_CURRENT_LATEST_ENTRY=$(jq --arg url "${BASE_URL}/${CURRENT_LATEST_VERSION}" '.[0] | .url = $url | del(.name)' <<< "$SWITCHER_CONTENT")
            NEW_ENTRY=$(jq -n --arg version "${version}" --arg url "$NEW_URL" --arg name "$version (latest)" \
              '{name: $name, version: $version, url: $url}')
            UPDATED_SWITCHER_CONTENT=$(jq --argjson new_entry "$NEW_ENTRY" --argjson updated_current_latest "$UPDATED_CURRENT_LATEST_ENTRY" '[$new_entry, $updated_current_latest] + .[1:]' <<< "$SWITCHER_CONTENT")
          else
            # File does not exist, initialize with current version as latest
            BASE_URL="https://animeshsasan.github.io/sphinx-deployment-test"
            NEW_URL="${BASE_URL}/latest/"
            UPDATED_SWITCHER_CONTENT=$(jq -n --arg version "${version}" --arg url "$NEW_URL" --arg name "$version (latest)" \
              '[{name: $name, version: $version, url: $url}]')
          fi

          SWITCHER_FILE="${version}/_static/switcher.json"
          echo "$UPDATED_SWITCHER_CONTENT" > "$SWITCHER_FILE"
          echo "${version}/_static/switcher.json has been updated successfully."
        fi

        # If this is a new release, update the link from /latest to it
        if [[ "${version}" != "dev" ]]; then
            echo -e "\nSetup link from ${version} to 'latest'."
            rm -f latest
            ln -sf ${version} latest
        fi
        # Stage the commit
        git add -A .
        echo -e "\nChanges to be applied:"
        git status
        # Configure git to be the GitHub Actions account
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        # If this is a dev build and the last commit was from a dev build
        # (detect if "dev" was in the previous commit message), reuse the
        # same commit
        if [[ "${version}" == "dev" && `git log -1 --format='%s'` == *"dev"* ]]; then
            echo -e "\nAmending last commit:"
            git commit --amend --reset-author -m "$message"
        else
            echo -e "\nMaking a new commit:"
            git commit -m "$message"
        fi
        # Make the push quiet just in case there is anything that could leak
        # sensitive information.
        echo -e "\nPushing changes to gh-pages."
        git push -fq origin gh-pages 2>&1 >/dev/null
        echo -e "\nFinished uploading generated files."
